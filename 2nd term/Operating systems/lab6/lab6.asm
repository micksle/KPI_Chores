title lab6 Kalinin

;приклад для обчислення (4*C-D/2+23)/(A*A-1)

.model small
.stack 100h

data segment
  	A dw 1					; записуємо значення, що буде використано
  	C dw 7
 	D dw 6
  	x dw ?					; змінна для запису результату обчислення
	divider dw ?				; проміжна змінна для значення дільника (A*A-1) 
	reduction dw ?				; проміжна змінна для зменшуваного (4*С)

  	error db "error, dividing by zero$"
  	result db "result: $"			; допоміжні речення у випадку ділення на 0 або
  	newLine db 0dh,0ah, '$'			; успішного виконання обчислення, та перехід да новий рядок
data ends

code segment
  	assume CS:code, DS:data			; співставляємо необхідні частини коду
begin:
  	mov AX, data				; заносимо адресу сегменту даних у регістр DS
  	mov DS, AX				; а адресу початку сегменту коду до CS

	mov AH, 09h				; виведення відступу зверху
	mov DX, offset newLine 
	int 21h	


  	mov AX, A				; рахуємо значення дільника
	cwd					; конвертуємо значення слова у подвійне слово
  	imul AX	
	dec AX					

 	cmp AX, 0				; порівнюємо з 0, якщо дорівнює
 	je @WARNING     			; переходимо до процедури завершення програми
	mov divider, AX				; інакше записуємо значення в проміжну змінну
	
	mov AX, 4 				; рахуємо значення дільника 4*С
	cwd
  	imul C
	mov reduction, AX			; записуємо значення в проміжну змінну		
	
	mov BX, 2				; рахуємо значеня D/2
	mov AX, D
	cwd
  	idiv BX
	
	sbb reduction, AX			; віднімаємо 4*C - D/2
	mov AX, reduction
	adc AX, 23				; додаємо до попереднього результату 23
 
	cwd
	idiv divider				; виконуємо дідення попереднього результату на дільник
	mov X, AX				; записуємо результат у кінцеву змінну Х
	
	mov AH, 09h				; виводимо повідомлення для кінцевого результату
	mov DX, offset result
	int 21h

	xor AX, AX				; обнуляємо значення регістра АХ
	mov AX, X				; записуємо значення результату в регістр АХ
	push AX 				; додаємо його в стек
	cmp AX, 0				; порівнюємо значення з 0
	jns @PLUS				; якщо додатнє, переходимо до процедури запису числа
	mov AH, 02h 
	mov DL, '-'				; інакше виводимо знак мінус на екран
	int 21h
	pop AX					; дістаємо значення зі стеку
	neg AX					; та змінюємо від'ємне значення на додатнє

@PLUS:
	xor CX, CX				; обнуляємо значення регістра СХ, визначаємо кількість цифр
	mov BX, 10				; для запису числа у десятковій системі записуємо значення 10 в регістр ВХ

@DIVISION: 					; процедура запису числа в десятковій системі
	xor DX, DX
	div BX					; ділимо вхідне число на 10
	push DX					; і записуємо у стек
	inc CX					; інкрементуємо змінну
	test AX, AX				; у випадку якщо число не дорівнює 0
	jnz @DIVISION				; повторюємо результат
	mov AH, 02h

@PRINT: 
	pop DX					; вивід результату на екран, шляхом 
	add DL, 30h				; переведення символу, що дістали із стеку у цифру
	int 21h
	loop @PRINT				; зациклюємо програму
	jmp @END	

@WARNING: 					; процедура завершення програми в разі виникнення помилки (ділення на 0)
	mov AH, 09h
	mov DX, offset error
	int 21h		

@END:						; процедура успішного завершення роботи програми
	mov AH, 4ch
	mov AL, 0
	int 21h 			
code ends

end begin
