title lab7 Kalinin

.model small
.stack 100h

;     | A/B + 1,  при A > B
; Х = | -2,       при A = B
;     | (A-B)/A,  при A < B

data segment
  	A dw 4						; записуємо значення, що буде використано
  	B dw -2
  	X dw ?						; змінна для запису результату обчислення

  	error db "error, dividing by zero$"		; речення, що інформує про ділення на 0 (ОДЗ)
  	more db "result for A > B: $"			; допоміжні речення, що виводять інформацію
  	less db "result for A < B: $"			; про результат ділення, та відношення А і В
	equal db "result for A = B: $"
	newLine db 0dh,0ah, '$'				; переведення каретки на новий рядок
data ends

code segment						; заносимо адресу сегменту даних у регістр DS
  	assume CS:code, DS:data				; а адресу початку сегменту коду до CS
begin:
  	mov AX, data					; адресу сегмента початку заносимо в регістр DS
  	mov DS, AX

	mov AH, 09h					; виводимо відступу зверху
	mov DX, offset newLine 
	int 21h	

  	mov AX, A					; заносимо необіхдні для порівняння змінні в регістри
	mov BX, B
  	cmp AX, BX					; порівнюємо значення А та В
	jg @MORE					; якщо А більше, переходимо до підрахунку цього випадку
	jl @LESS					; для А < B переходимо до відповідного розділу

	mov AH, 09h					; інакше виводимо допоміжне повідомлення стосовно
	mov DX, offset equal				; рівності двох змінних
	int 21h

	xor AX, AX					; обнуляємо значення регістра АХ
	mov AX, -2					; заносимо необхідне значення в регістр АХ
	mov X, AX					; заносимо результат для А = В в змінну Х
	jmp @START					; переходимо до виведення результату на екран

@MORE:							; рахуємо значення виразу при A > B
	xor AX, AX
	mov BX, B
	cmp BX, 0					; перевірка на ОДЗ (В != 0)
	je @WARNING					; у випадку В = 0 передаємо команду обробки помилки

	mov AH, 09h					; інакше виводимо повідомлення про результат
	mov DX, offset more				; обчислення на екран 
	int 21h	
	
	mov AX, A					; заносимо значення А в регістр АХ
	cwd						
	idiv B						; виконуємо А/В 
	inc AX						; А/В + 1
	mov X, AX
	jmp @START					; переходимо до виведення результату

@LESS:							; рахуємо значення виразу при A < B			
	xor AX, AX
	mov AX, A
	cmp AX, 0					; перевіряємо функцію на ОДЗ (А != 0)
	je @WARNING					; якщо А = 0 переходимо до обробки блоку попередження

	mov AH, 09h					; виводимо допоміжне повідомлення про 
	mov DX, offset less				; умову обчислення функції (А < B)
	int 21h	
	
	mov AX, A
	sbb AX, B					; обчислюємо (А-В)
	cwd
	idiv A						; рахуємо значення (А-В)/А
	mov X, AX 					; записуємо результат в змінну Х
	jmp @START					; переходимо до виведення результату

@START:							; початок блоку виведення результату
	xor AX, AX					
	mov AX, X					; записуємо значення результату в регістр АХ
	push AX 					; додаємо його в стек
	cmp AX, 0					; порівнюємо значення з 0
	jns @PLUS					; якщо додатнє, переходимо до процедури запису числа
	mov AH, 02h 
	mov DL, '-'					; інакше виводимо знак мінус на екран
	int 21h
	pop AX						; дістаємо значення зі стеку
	neg AX					

@PLUS:
	xor CX, CX					; обнуляємо значення регістра СХ (остачу)
	mov BX, 10					; для запису числа у десятковій системі

@DIVISION: 						; процедура запису числа в десятковій системі
	xor DX, DX
	div BX						; ділимо вхідне число на 10
	push DX						; і записуємо у стек
	inc CX						; збільшуємо значення лічильника
	test AX, AX					; у випадку якщо число не дорівнює 0
	jnz @DIVISION					; повторюємо результат
	mov AH, 02h

@PRINT: 
	pop DX						; вивід результату на екран, шляхом переведення
	add DL, 30h					; символу, що дістали із стеку у цифру за ASCII
	int 21h
	loop @PRINT					; зациклюємо програму поки СХ != 0
	jmp @END					; переходимо до завершення програми

@WARNING: 						; блок завершення програми в разі виникнення помилки (ділення на 0)
	mov AH, 09h
	mov DX, offset error
	int 21h	

@END:							; блок успішного завершення роботи програми
	mov AH, 4ch
	mov AL, 0
	int 21h 			
code ends

end begin
